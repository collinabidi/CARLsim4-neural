/*!

\page tut7_pti Tutorial 7: Parameter Tuning Interface (PTI)
\tableofcontents
\author Kristofor D. Carlson

\section tut7s1_intro 7.1 Introduction

In this tutorial we introduce the parameter tuning interface and how to tune the weight ranges of a
simple SNN to achieve a particular target firing rate. We will be tuning four parameter values that
represent the weight ranges. The layout of the SNN is as follows. We have 10 input excitatory
neurons, 10 regular spiking (RS) excitatory neurons that receive this input, and 10 fast spiking
(FS) izhikevich neurons that receive input from the excitatory RS neurons. Additionally, the
inhibitory group is connected to the RS excitatory group and the RS excitatory group is connected to
itself recurrently. There are therefore 4 connection weight ranges to be tuned. The goal of the
tuning is make the RS excitatory group have an average firing rate of 10 Hz and make the FS
inhibitory group have an average firing rate of 20 Hz.

All the required files are found in the doc/source/tutorial/3_pti directory. The user is encouraged
to follow along and experiment with the source code found there.

This tutorial assumes:
- ECJ version 22 or greater is installed.
- CARLsim 4.0 is installed.
- CARLsim4 and ECJ environment variables are configured correctly.

The overview of parameter tuning is as follows. ECJ handles all steps of the evolutionary algorithm
(EA) except for the fitness evaluation which is done by CARLsim through the implementation of an
experiment class function called <tt>run</tt>.


A more in-depth overview of CARLsim and ECJ can be found in \ref ch10_ecj.

\section tut7s2_parameter_file 7.2 The ECJ Parameter File

This example has an ECJ parameter file named <tt>TuneFiringRatesECJExperiment.params</tt>. As
mentioned in \ref ch10_ecj, users must first configure this file if they want to parameter tune
CARLsim programs.

We first specify that we want a maximum number of 50 generations and a population size of 10. This
means 10 individuals (each a separate SNN) will be run in parallel by CARLsim:

\code
generations =        50
pop.subpop.0.size =  10
\endcode

There are four parameter values to be tuned so we set:

\code
pop.subpop.0.species.genome-size =      4
\endcode

We will allow all four weight ranges to be tuned within the same parameter range although each
individual parameter can be given it's own range (see \ref ch10_ecj). The minimum weight value for
each weight is then 0.0005 while the maximum value is 0.5 as shown below:

\code
pop.subpop.0.species.min-gene =         0.0005
pop.subpop.0.species.max-gene =         0.5
\endcode

Finally we must specify the name of the carlsim binary that ECJ should execute every generation to
obtain fitness values. This is done below. Notice there is a <tt>$</tt> before the filename. This
indicates that the location of the file is relative to the location of the parameter file.

\code
eval.problem.simulationCommand =        $carlsim_tuneFiringRatesECJ
\endcode

Of course any of these parameters can be changed. For more information on ECJ parameter file
configuration please visit the ECJ <a href="http://cs.gmu.edu/~eclab/projects/ecj/">homepage</a>.

\section tut7s3_experiment_class 7.3 The Experiment Class
We next discuss the CARLsim code found in the experiment class. This code is found in the
main_tuneFiringRatesECJ.cpp file. Users should use this tutorial as template for writing their own
code. First a specific experiment class must be inherited from the base class and default
constructor must be defined.:

\code
class TuneFiringRatesECJExperiment : public Experiment {
public:

TuneFiringRatesECJExperiment() {}
\endcode

After that, the user should only be concerned with writing the <tt>run</tt> member function.

\code
...
void run(const ParameterInstances &parameters, std::ostream &outputStream) const {
	int indiNum = parameters.getNumInstances();

	int poissonGroup[indiNum];
	int excGroup[indiNum];
	int inhGroup[indiNum];
	SpikeMonitor* excMonitor[indiNum];
	SpikeMonitor* inhMonitor[indiNum];
	float excHz[indiNum];
	float inhHz[indiNum];
	float excError[indiNum];
	float inhError[indiNum];
	float fitness[indiNum];
...
\endcode

Notice we can use the parameters object to query how many instances/individuals we have defined in
the ECJ parameter file. Now that we have that value, we manually create arrays neuron groups of size
<tt>indiNum</tt>. In our case we have defined 10 individuals per generation.

Next we create our CARLsim network object and assign the 4 parameter values generated by ECJ to our
10 SNN individuals. We iterate over all 10 individuals and assign them 4 distinct parameters each.

\code
CARLsim* const network = new CARLsim("tuneFiringRatesECJ", GPU_MODE, SILENT);

for(unsigned int i = 0; i < parameters.getNumInstances(); i++) {
	poissonGroup[i] = network->createSpikeGeneratorGroup("poisson", NUM_NEURONS, EXCITATORY_NEURON);
	excGroup[i] = network->createGroup("exc", NUM_NEURONS, EXCITATORY_NEURON);
	inhGroup[i] = network->createGroup("inh", NUM_NEURONS, INHIBITORY_NEURON);

	network->setNeuronParameters(excGroup[i], REG_IZH[0], REG_IZH[1], REG_IZH[2], REG_IZH[3]);
	network->setNeuronParameters(inhGroup[i], FAST_IZH[0], FAST_IZH[1], FAST_IZH[2], FAST_IZH[3]);
	network->setConductances(true,COND_tAMPA,COND_tNMDA,COND_tGABAa,COND_tGABAb);

	network->connect(poissonGroup[i], excGroup[i], "random", RangeWeight(parameters.getParameter(i,0)), 0.5f, RangeDelay(1));
	network->connect(excGroup[i], excGroup[i], "random", RangeWeight(parameters.getParameter(i,1)), 0.5f, RangeDelay(1));
	network->connect(excGroup[i], inhGroup[i], "random", RangeWeight(parameters.getParameter(i,2)), 0.5f, RangeDelay(1));
	network->connect(inhGroup[i], excGroup[i], "random", RangeWeight(parameters.getParameter(i,3)), 0.5f, RangeDelay(1));

}
\endcode

We then setup the SNNs, begin recording their spike data with a SpikeMonitor, and run the SNNs.

\code
...
network->setupNetwork();
...
excMonitor[i] = network->setSpikeMonitor(excGroup[i], "/dev/null");
inhMonitor[i] = network->setSpikeMonitor(inhGroup[i], "/dev/null");

excMonitor[i]->startRecording();
inhMonitor[i]->startRecording();
...
network->runNetwork(runTime,0);
\endcode

Finally we stop recording, get the average firing rate of each group and compute a fitness function
which is output to ECJ using standard Linux streams.

\code
excMonitor[i]->stopRecording();
inhMonitor[i]->stopRecording();

excHz[i] = excMonitor[i]->getPopMeanFiringRate();
inhHz[i] = inhMonitor[i]->getPopMeanFiringRate();

excError[i] = fabs(excHz[i] - EXC_TARGET_HZ);
inhError[i] = fabs(inhHz[i] - INH_TARGET_HZ);

fitness[i] = 1/(excError[i] + inhError[i]);
outputStream << fitness[i] << endl;
\endcode

To compile and run the tuning framework we simply type:

\code
make
./launchCARLsimECJ.sh
\endcode

The simulation should run to completion and output the best fitness each generation.

This results in an ECJ out.stat file that we talk about in the next section.


\section tut7s4_output_files 7.4 ECJ Output Files

The output.stat file generated contains the best fitness for that generation along with the four
parameter values associated with that individual. CARLsim users can then use these parameters for
their tuned SNN models.

\see \ref ch10_ecj

*/
